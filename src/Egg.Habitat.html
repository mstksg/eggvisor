<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds             #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DeriveFunctor         #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric         #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances     #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase            #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE OverloadedStrings     #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE PartialTypeSignatures #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes            #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE RecordWildCards       #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables   #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TemplateHaskell       #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TupleSections         #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications      #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies          #-}</span><span>
</span><a name="line-16"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators         #-}</span><span>
</span><a name="line-17"></a><span class="hs-pragma">{-# LANGUAGE TypeSynonymInstances  #-}</span><span>
</span><a name="line-18"></a><span>
</span><a name="line-19"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Habitat</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-20"></a><span>    </span><a href="Egg.Habitat.html#Hab"><span class="hs-identifier hs-type">Hab</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habName"><span class="hs-identifier hs-var">habName</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habBaseCapacity"><span class="hs-identifier hs-var">habBaseCapacity</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCosts"><span class="hs-identifier hs-var">habCosts</span></a><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HabData"><span class="hs-identifier hs-type">HabData</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HabData"><span class="hs-identifier hs-var">_HabData</span></a><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#SomeHabData"><span class="hs-identifier hs-type">SomeHabData</span></a><span>
</span><a name="line-23"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HabStatus"><span class="hs-identifier hs-type">HabStatus</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HabStatus"><span class="hs-identifier hs-var">_HabStatus</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#hsSlots"><span class="hs-identifier hs-var">hsSlots</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#hsPop"><span class="hs-identifier hs-var">hsPop</span></a><span>
</span><a name="line-24"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#IsCalm"><span class="hs-identifier hs-type">IsCalm</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NotCalm"><span class="hs-identifier hs-var">_NotCalm</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_Calm"><span class="hs-identifier hs-var">_Calm</span></a><span>
</span><a name="line-25"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#initHabStatus"><span class="hs-identifier hs-var">initHabStatus</span></a><span>
</span><a name="line-26"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habAt"><span class="hs-identifier hs-var">habAt</span></a><span>
</span><a name="line-27"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#totalChickens"><span class="hs-identifier hs-var">totalChickens</span></a><span>
</span><a name="line-28"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#baseHabCapacity"><span class="hs-identifier hs-var">baseHabCapacity</span></a><span>
</span><a name="line-29"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#baseHabCapacities"><span class="hs-identifier hs-var">baseHabCapacities</span></a><span>
</span><a name="line-30"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#totalHabCapacity"><span class="hs-identifier hs-var">totalHabCapacity</span></a><span>
</span><a name="line-31"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCapacity"><span class="hs-identifier hs-var">habCapacity</span></a><span>
</span><a name="line-32"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#fullHabs"><span class="hs-identifier hs-var">fullHabs</span></a><span>
</span><a name="line-33"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#slotAvailability"><span class="hs-identifier hs-var">slotAvailability</span></a><span>
</span><a name="line-34"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#availableSpace"><span class="hs-identifier hs-var">availableSpace</span></a><span>
</span><a name="line-35"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#availableSpaces"><span class="hs-identifier hs-var">availableSpaces</span></a><span>
</span><a name="line-36"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#maxOutHabs"><span class="hs-identifier hs-var">maxOutHabs</span></a><span>
</span><a name="line-37"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#addChickens"><span class="hs-identifier hs-var">addChickens</span></a><span>
</span><a name="line-38"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCapacities"><span class="hs-identifier hs-var">habCapacities</span></a><span>
</span><a name="line-39"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habHistory"><span class="hs-identifier hs-var">habHistory</span></a><span>
</span><a name="line-40"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habPrice"><span class="hs-identifier hs-var">habPrice</span></a><span>
</span><a name="line-41"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#upgradeHab"><span class="hs-identifier hs-var">upgradeHab</span></a><span>
</span><a name="line-42"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habUpgrades"><span class="hs-identifier hs-var">habUpgrades</span></a><span>
</span><a name="line-43"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#internalHatcheryRate"><span class="hs-identifier hs-var">internalHatcheryRate</span></a><span>
</span><a name="line-44"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#totalGrowthRate"><span class="hs-identifier hs-var">totalGrowthRate</span></a><span>
</span><a name="line-45"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HWaitError"><span class="hs-identifier hs-type">HWaitError</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HWENoInternalHatcheries"><span class="hs-identifier hs-var">_HWENoInternalHatcheries</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HWEMaxHabCapacity"><span class="hs-identifier hs-var">_HWEMaxHabCapacity</span></a><span>
</span><a name="line-46"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#waitTilNextFilled"><span class="hs-identifier hs-var">waitTilNextFilled</span></a><span>
</span><a name="line-47"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#stepHabs"><span class="hs-identifier hs-var">stepHabs</span></a><span>
</span><a name="line-48"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#stepHabsDT"><span class="hs-identifier hs-var">stepHabsDT</span></a><span>
</span><a name="line-49"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#WaitTilRes"><span class="hs-identifier hs-type">WaitTilRes</span></a><span class="hs-special">(</span><a href="Egg.Habitat.html#WaitTilSuccess"><span class="hs-identifier hs-var">WaitTilSuccess</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#NoWait"><span class="hs-identifier hs-var">NoWait</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#NonStarter"><span class="hs-identifier hs-var">NonStarter</span></a><span class="hs-special">)</span><span>
</span><a name="line-50"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_WaitTilSuccess"><span class="hs-identifier hs-var">_WaitTilSuccess</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NoWait"><span class="hs-identifier hs-var">_NoWait</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NonStarter"><span class="hs-identifier hs-var">_NonStarter</span></a><span>
</span><a name="line-51"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#wtrTime"><span class="hs-identifier hs-var">wtrTime</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#wtrRes"><span class="hs-identifier hs-var">wtrRes</span></a><span>
</span><a name="line-52"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#waitTilPop"><span class="hs-identifier hs-var">waitTilPop</span></a><span>
</span><a name="line-53"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#fillTimes"><span class="hs-identifier hs-var">fillTimes</span></a><span>
</span><a name="line-54"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-55"></a><span>
</span><a name="line-56"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span>
</span><a name="line-57"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span> </span><span class="hs-keyword">hiding</span><span>        </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">.=</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-58"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>
</span><a name="line-59"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span><span>
</span><a name="line-60"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Dependent</span><span class="hs-operator">.</span><span class="hs-identifier">Sum</span><span>
</span><a name="line-61"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Finite</span><span>
</span><a name="line-62"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-63"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-64"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-65"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span>
</span><a name="line-66"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Combinator.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TC</span><span>
</span><a name="line-67"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Fin</span><span>
</span><a name="line-68"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>           </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-69"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Vector.Sized.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-70"></a><span class="hs-keyword">import</span><span>           </span><a href="Egg.Commodity.html"><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Commodity</span></a><span>
</span><a name="line-71"></a><span class="hs-keyword">import</span><span>           </span><a href="Egg.Research.html"><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Research</span></a><span>
</span><a name="line-72"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-73"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TL</span><span>
</span><a name="line-74"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span>
</span><a name="line-75"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Natural</span><span>
</span><a name="line-76"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Printf</span><span>
</span><a name="line-77"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-78"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Map</span><span>                   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">M</span><span>
</span><a name="line-79"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span>
</span><a name="line-80"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SV</span><span>
</span><a name="line-81"></a><span>
</span><a name="line-82"></a><span class="hs-keyword">data</span><span> </span><a name="Hab"><a href="Egg.Habitat.html#Hab"><span class="hs-identifier">Hab</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="Hab"><a href="Egg.Habitat.html#Hab"><span class="hs-identifier">Hab</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="_habName"><a href="Egg.Habitat.html#_habName"><span class="hs-identifier">_habName</span></a></a><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">T</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">Text</span><span>
</span><a name="line-83"></a><span>               </span><span class="hs-special">,</span><span> </span><a name="_habBaseCapacity"><a href="Egg.Habitat.html#_habBaseCapacity"><span class="hs-identifier">_habBaseCapacity</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Natural</span><span>
</span><a name="line-84"></a><span>               </span><span class="hs-special">,</span><span> </span><a name="_habCosts"><a href="Egg.Habitat.html#_habCosts"><span class="hs-identifier">_habCosts</span></a></a><span>        </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Vec</span><span> </span><span class="hs-identifier hs-type">N4</span><span> </span><a href="Egg.Commodity.html#Bock"><span class="hs-identifier hs-type">Bock</span></a><span>
</span><a name="line-85"></a><span>               </span><span class="hs-special">}</span><span>
</span><a name="line-86"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-87"></a><span>
</span><a name="line-88"></a><span class="hs-identifier hs-var">makeLenses</span><span> </span><span class="hs-char">''Hab

newtype HabData habs = HabData { _hdHabs :: SV.Vector habs Hab }
  deriving (Show, Eq, Ord, Generic)

makePrisms ''HabData
makeWrapped ''HabData

type SomeHabData = DSum Sing HabData

data HabStatus habs
    = HabStatus { _hsSlots :: Vec N4 (Maybe (Finite habs))
                , _hsPop   :: Vec N4 Double
                }
  deriving (Show, Eq, Ord, Generic)

makeLenses ''HabStatus

_HabStatus :: Iso' (HabStatus habs) (Vec N4 (Maybe (Finite habs), Double))
_HabStatus = iso (\hs -&gt; liftA2 (,) (_hsSlots hs) (_hsPop hs))
                 (uncurry HabStatus . unzipV)

habParseOptions :: Options
habParseOptions = defaultOptions
    { fieldLabelModifier = camelTo2 '-' . drop 4
    }

instance FromJSON Hab where
    parseJSON  = genericParseJSON  habParseOptions
instance ToJSON Hab where
    toJSON     = genericToJSON     habParseOptions
    toEncoding = genericToEncoding habParseOptions

instance FromJSON SomeHabData where
    parseJSON o = do
      habs &lt;- parseJSON o
      SV.withSized habs $ \habsV -&gt;
        return $ SNat :=&gt; HabData habsV
instance ToJSON SomeHabData where
    toJSON = \case
        _ :=&gt; r -&gt; toJSON r
    toEncoding = \case
        _ :=&gt; r -&gt; toEncoding r
instance KnownNat habs =&gt; FromJSON (HabData habs) where
    parseJSON o = do
      habs &lt;- parseJSON o
      case SV.toSized habs of
        Nothing    -&gt; fail $ printf &quot;Bad number of items in list. (Expected %d, got %d)&quot;
                         (fromSing (SNat @habs)) (length habs)
        Just habsV -&gt; return $ HabData habsV
instance ToJSON (HabData habs) where
    toJSON     = toJSON     . SV.fromSized . _hdHabs
    toEncoding = toEncoding . SV.fromSized . _hdHabs

data IsCalm = NotCalm | Calm
    deriving (Show, Eq, Ord, Enum)

makePrisms ''IsCalm

data WaitTilRes f a
    = WaitTilSuccess { _wtrTime :: Double, _wtrRes :: f a }
    -- | MaxPopIn       { _wtrTime :: Double }
    | NoWait
    | NonStarter
  deriving (Show, Eq, Ord, Functor)

makePrisms ''WaitTilRes
makeLenses ''WaitTilRes

data HWaitError = HWENoInternalHatcheries
                | HWEMaxHabCapacity

makePrisms ''HWaitError

-- | Initial 'HabStatus' to start off the game.
initHabStatus :: (KnownNat habs, 1 TL.&lt;= habs) =&gt; HabStatus habs
initHabStatus = HabStatus (Just 0 :+ pure Nothing) (pure 0)

-- | Base capacity of each slot.
baseHabCapacities
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; HabStatus habs
    -&gt; Vec N4 Natural
baseHabCapacities hd = fmap go . _hsSlots
  where
    go = maybe 0 (\h -&gt; hd ^. _HabData . ixSV h . habBaseCapacity)

-- | Total base capacity of all slots.
baseHabCapacity
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; HabStatus habs
    -&gt; Natural
baseHabCapacity HabData{..} =
    sumOf $ hsSlots
          . folded
          . folded
          . to (SV.index _hdHabs)
          . habBaseCapacity

-- | Total capacity of all hatcheries, factoring in bonuses.
totalHabCapacity
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Double
totalHabCapacity hd bs =
    sumOf $ to (baseHabCapacity hd)
          . to fromIntegral
          . bonusingFor bs BTHabCapacity

-- | Capacities of all slots, factoring in bonuses.
habCapacities
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 Double
habCapacities hd bs = fmap ( bonusEffectFor bs BTHabCapacity
                           . fromIntegral
                           )
                    . baseHabCapacities hd

-- | Hab at the given slot
habAt :: KnownNat habs =&gt; HabData habs -&gt; HabStatus habs -&gt; Fin N4 -&gt; Maybe Hab
habAt HabData{..} hs i = hs ^? hsSlots . ixV i . folded . to (SV.index _hdHabs)

-- | Total number of chickens
totalChickens
    :: HabData habs
    -&gt; HabStatus habs
    -&gt; Double
totalChickens HabData{..} = sumOf $ hsPop . folded

-- | How many of each hab is currently owned.  If key is not found, zero
-- purchases is implied.
habHistory :: HabStatus habs -&gt; M.Map (Finite habs) (Fin N5)
habHistory = M.mapMaybe (natFin . someNat)
           . M.fromListWith (+)
           . toListOf (hsSlots . folded . folded . to (, 1))

-- | Get the BASE price of a given hab, if a purchase were to be made.
-- Does not check if purchase is legal (see 'upgradeHab').
--
-- Returns Nothing if four copies of this hab are already currently owned.
habPrice :: KnownNat habs =&gt; HabData habs -&gt; HabStatus habs -&gt; Finite habs -&gt; Maybe Bock
habPrice hd hs hab = fmap priceOf
                   . maybe (Just FZ) TC.strengthen
                   . M.lookup hab
                   . habHistory
                   $ hs
  where
    priceOf :: Fin N4 -&gt; Bock
    priceOf i = hd ^. _HabData . ixSV hab . habCosts . ixV i

-- | Get the actual capacity for a given hab, with given bonuses.
habCapacity
    :: Bonuses
    -&gt; Hab
    -&gt; Double
habCapacity bs = view $ habBaseCapacity
                      . to fromIntegral
                      . bonusingFor bs BTHabCapacity

-- | Compute the base internal hatchery rate (chickens per second per
-- hatchery) from bonuses.
internalHatcheryRate :: Bonuses -&gt; IsCalm -&gt; Double
internalHatcheryRate bs cm =
    0 ^. bonusingFor bs BTInternalHatchery . dividing 60 . multiplying calmBonus
  where
    calmBonus = case cm of
        NotCalm -&gt; 1
        Calm    -&gt; 1 ^. bonusingFor bs BTInternalHatcheryCalm

-- | Total hab growth rate, in chickens per second.
totalGrowthRate
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; HabStatus habs
    -&gt; Double
totalGrowthRate hd bs cm hs =
    internalHatcheryRate bs cm
        ^. multiplying (1 + sharingRate * fromIntegral numFull)
         . multiplying (4 - fromIntegral numFull)
  where
    numFull      :: Finite 5
    numFull      = sumOf (availableSpace hd bs . to (maybe 1 (const 0))) hs
    sharingRate  :: Double
    sharingRate  = 0 ^. bonusingFor bs BTInternalHatcherySharing

-- | Purchase a hab upgrade.  Returns cost and new hab status, if
-- purchase is valid.
--
-- Purchase is invalid if purchasing a hab in a slot where a greater hab
-- is already purchased.
upgradeHab
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; Fin N4
    -&gt; Finite habs
    -&gt; HabStatus habs
    -&gt; Either (Finite habs) (Bock, HabStatus habs)
upgradeHab hd bs slot hab hs0 =
    getComp . flip (hsSlots . ixV slot) hs0 $ \s0 -&gt; Comp $ do
      case s0 of
        Just h  | h &gt;= hab -&gt; Left h
        _                  -&gt; Right ()
      -- should always be valid of the previous condition is true
      let price = fromJust $ habPrice hd hs0 hab
      return (price ^. bonusingFor bs BTBuildCosts, Just hab)

-- | Get all possible Hab upgrades
habUpgrades
    :: forall habs. (KnownNat habs)
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; VecT N4 (SV.Vector habs :.: Either (Finite habs)) Bock
habUpgrades hd bs hs = hs ^. hsSlots
                           &amp; vmap (Comp . go . getI)
  where
    hist :: M.Map (Finite habs) (Fin N5)
    hist = habHistory hs
    go :: Maybe (Finite habs) -&gt; SV.Vector habs (Either (Finite habs) Bock)
    go i = hd ^. _HabData
               &amp; SV.imap
                   (\j h -&gt; do
                       case i of
                         Just i' | i' &gt;= j -&gt; Left i'
                         _                 -&gt; Right ()
                       let n = fromJust . maybe (Just FZ) TC.strengthen $ M.lookup j hist
                       return $ h ^. habCosts . ixV n . bonusingFor bs BTBuildCosts
                   )

-- | Which habs are full?
fullHabs
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 Bool
fullHabs hd bs = fmap (uncurry isFull) . view _HabStatus
  where
    isFull :: Maybe (Finite habs) -&gt; Double -&gt; Bool
    isFull s c = case s of
      Nothing -&gt; True
      Just m  -&gt;
        let totCap = hd ^. _HabData . ixSV m . to (habCapacity bs)
        in  c &gt;= totCap

-- | Gives total avaiable space of each hab (Nothing if hab full), and also
-- the capacity of each hab.
slotAvailability
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 (Maybe Double, Double)
slotAvailability hd bs hs = checkAvail &lt;$&gt; caps &lt;*&gt; (hs ^. hsPop)
  where
    caps :: Vec N4 Double
    caps = habCapacities hd bs hs
    checkAvail :: Double -&gt; Double -&gt; (Maybe Double, Double)
    checkAvail cap pop
        | pop &gt;= cap = (Nothing, cap)
        | otherwise  = (Just (cap - pop), cap)

-- | Traverse over the available space of each hab slot.
--
-- 'Nothing' means slot is full, @'Just' a@ means there is @a@ room left.
--
-- Will truncate the set @a@ if it's too big, making it an improper
-- traversal if @a@ is set to be too large.
--
-- Will truncate the set @a@ if it's negative (to zero), making it an
-- imporper traversal if @a@ is set to be negative.
availableSpace
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; Traversal' (HabStatus habs) (Maybe Double)
availableSpace hd bs f0 hs = (_HabStatus . traverse) (uncurry (go f0)) hs
  where
    go  :: Applicative f
        =&gt; (Maybe Double -&gt; f (Maybe Double))
        -&gt; Maybe (Finite habs)
        -&gt; Double
        -&gt; f (Maybe (Finite habs), Double)
    go f h p = f avail &lt;&amp;&gt; \case
        Nothing -&gt; (h, fromMaybe 0 cap)
        Just a' -&gt; (h, case cap of
                         Nothing -&gt; 0
                         Just c
                           | a' &lt;= 0 -&gt; c
                           | otherwise -&gt; max 0 (c - a')
                   )
      where
        avail = case cap of
                  Nothing -&gt; Nothing
                  Just c  | p &lt; c     -&gt; Just (c - p)
                          | otherwise -&gt; Nothing
        cap = h &lt;&amp;&gt; \i -&gt; hd ^. _HabData
                              . ixSV i
                              . habBaseCapacity
                              . to  fromIntegral
                              . bonusingFor bs BTHabCapacity

-- | Traverse over the available space of each hab slot.
--
-- 'Nothing' means slot is full, @'Just' a@ means there is @a@ room left.
--
-- Will truncate the set @a@ if it's too big, making it an improper
-- lens if @a@ is set to be too large.
--
-- Will truncate the set @a@ if it's negative (to zero), making it an
-- improper lens if @a@ is set to be negative.
availableSpaces
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; Lens' (HabStatus habs) (Vec N4 (Maybe Double))
availableSpaces hd bs f0 hs = (_HabStatus) (go f0) hs
  where
    go  :: Functor f
        =&gt; (Vec N4 (Maybe Double) -&gt; f (Vec N4 (Maybe Double)))
        -&gt; Vec N4 (Maybe (Finite habs), Double)
        -&gt; f (Vec N4 (Maybe (Finite habs), Double))
    go f hv = liftA3 restore (fst &lt;$&gt; hv) caps &lt;$&gt; f avails
      where
        restore h cap = \case
          Nothing -&gt; (h, fromMaybe 0 cap)
          Just a' -&gt; (h, case cap of
                           Nothing -&gt; 0
                           Just c
                             | a' &lt;= 0 -&gt; c
                             | otherwise -&gt; max 0 (c - a')
                     )
        (avails, caps) = unzipV $ uncurry availCap &lt;$&gt; hv
    availCap :: Maybe (Finite habs) -&gt; Double -&gt; (Maybe Double, Maybe Double)
    availCap h p = (subtract p &lt;$&gt; mfilter (&gt; p) cap, cap)
      where
        cap = h &lt;&amp;&gt; \i -&gt; hd ^. _HabData
                              . ixSV i
                              . habBaseCapacity
                              . to  fromIntegral
                              . bonusingFor bs BTHabCapacity


-- | Fill up with max chickens
maxOutHabs
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; HabStatus habs
maxOutHabs hd bs = set (availableSpace hd bs) Nothing

-- | Calculate the time until the next hab is full, and return the updated
-- habs after that time.  Returns Nothing if all habs are full.
--
-- Also returns the current total fill rate per hatchery, taking into
-- account all bonuses.
--
-- Conclusions:
--
-- 1. No internal hatcheries
-- 2. All habs are already full.
-- 3. Hab n filled after a given amount of time.
waitTilNextFilled
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; HabStatus habs
    -&gt; Either HWaitError (((Fin N4, Double), Double), HabStatus habs)
waitTilNextFilled hd bs cm hs
    | internalRate &lt;= 0 = Left HWENoInternalHatcheries
    | otherwise         = case nextFill of
        Nothing      -&gt; Left HWEMaxHabCapacity
        Just r@(_,t) -&gt; Right ((r, totalRate), fillIt t)
  where
    avails :: Vec N4 (Maybe Double, Double)
    avails = slotAvailability hd bs hs
    internalRate :: Double
    internalRate = internalHatcheryRate bs cm
    numFull      :: Natural
    numFull      = sumOf (folded . to (maybe 1 (const 0) . fst)) avails
    sharingRate  :: Double
    sharingRate  = 0 ^. bonusingFor bs BTInternalHatcherySharing
    totalRate    :: Double
    totalRate    = internalRate * (1 + sharingRate * fromIntegral numFull)
    fillAtRate   :: Vec N4 (Maybe Double)
    fillAtRate = (fst &lt;$&gt; avails) &amp; mapped . mapped %~ (/ totalRate)
    nextFill :: Maybe (Fin N4, Double)
    nextFill = ifoldr (go . fst) Nothing fillAtRate
      where
        go  :: Fin N4
            -&gt; Maybe Double
            -&gt; Maybe (Fin N4, Double)
            -&gt; Maybe (Fin N4, Double)
        go i (Just t) m@(Just (_, mt)) | t &lt; mt    = Just (i, t)
                                       | otherwise = m
        go i mt      Nothing                       = (i,) &lt;$&gt; mt
        go _ Nothing m@(Just _)                    = m
    fillIt :: Double -&gt; HabStatus habs
    fillIt t = hs &amp; availableSpace hd bs . mapped -~ totalRate * t

-- | Times for each hab to be filled.
fillTimes
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; HabStatus habs
    -&gt; Either HWaitError (Vec N4 Double)
fillTimes hd bs cm hs0 = go space0 hs0
  where
    space0 = maybe (Just 0) (const Nothing ) . fst &lt;$&gt;
               slotAvailability hd bs hs0
    go  :: Vec N4 (Maybe Double)
        -&gt; HabStatus habs
        -&gt; Either HWaitError (Vec N4 Double)
    go ts0 hs1 = do
      (((n, t), _), hs2) &lt;- waitTilNextFilled hd bs cm hs1
      let ts1 = ts0 &amp; ixV n .~ Just t
      case sequence ts1 of
        Just ts -&gt; return ts
        Nothing -&gt; liftA2 (maybe id (+)) ts1 &lt;$&gt; go ts1 hs2

-- | Steps the 'HabStatus' over the given time interval.
stepHabs
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; Double           -- ^ time interval to step
    -&gt; HabStatus habs   -- ^ initial status
    -&gt; HabStatus habs
stepHabs hd bs cm = go
  where
    go :: Double -&gt; HabStatus habs -&gt; HabStatus habs
    go dt hs0 = case waitTilNextFilled hd bs cm hs0 of
        Left  _                       -&gt; hs0
        Right (((_, tFill), rt), hs1)
          | dt &lt; tFill -&gt; hs0 &amp; availableSpace hd bs . mapped -~ rt * dt
          | otherwise  -&gt;
                go (dt - tFill) hs1

-- | Step the 'HabStatus' over a sufficiently SMALL (infinitessimal) time
-- interval @dt@.
--
-- Assumes that a hab will not become newly filled during this time
-- interval.
--
-- Mostly useful for &quot;continuous&quot; simulations.  For larger time periods
-- where habs may fill up over the period, use 'stepHabs'.
stepHabsDT
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; Double           -- ^ small (infinitessimal) time interval to step
    -&gt; HabStatus habs   -- ^ initial status
    -&gt; HabStatus habs
stepHabsDT hd bs cm dt hs = hs &amp; availableSpace hd bs . mapped -~ totalRate * dt
  where
    internalRate :: Double
    internalRate = internalHatcheryRate bs cm
    numFull      :: Natural
    numFull      = sumOf (availableSpace hd bs . to (maybe 1 (const 0))) hs
    sharingRate  :: Double
    sharingRate  = 0 ^. bonusingFor bs BTInternalHatcherySharing
    totalRate    :: Double
    totalRate    = internalRate * (1 + sharingRate * fromIntegral numFull)

-- | Time until a given population is reached.
--
-- If wait and no result, it means the result is the time until habs are
-- full.
waitTilPop
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; Natural
    -&gt; HabStatus habs
    -&gt; WaitTilRes Maybe (HabStatus habs)
waitTilPop hd bs cm goal hs0
    | pop0 &gt; goal' = NoWait
    | otherwise    = go pop0 hs0
  where
    goal' = fromIntegral goal
    pop0 :: Double
    pop0 = sumOf (hsPop . folded) hs0
    go :: Double -&gt; HabStatus habs -&gt; WaitTilRes Maybe (HabStatus habs)
    go currPop hs1 = case waitTilNextFilled hd bs cm hs1 of
      Left HWENoInternalHatcheries -&gt; NonStarter
      Left HWEMaxHabCapacity       -&gt; WaitTilSuccess 0 Nothing
      Right (((_, dt), rt), hs2)  -&gt;
        let newPop = sumOf (hsPop . folded) hs2
        in  if newPop &gt;= goal'
              then let dt'    = (goal' - currPop) / rt
                       filled = hs2 &amp; availableSpace hd bs . mapped -~ rt * dt'
                   in  WaitTilSuccess dt' (Just filled)
              else go newPop hs2 &amp; wtrTime +~ dt

-- | Add chickens to habs, distributing properly.  Returns any leftovers.
addChickens
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; Double
    -&gt; HabStatus habs
    -&gt; (Maybe Double, HabStatus habs)
addChickens hd bs c = availableSpaces hd bs $ \avails -&gt;
    let totAvail     = sumOf (folded . folded) avails
        newAvailPerc = 1 - c / totAvail
    in  if c &gt;= totAvail
          then (Just (c - totAvail), pure Nothing                            )
          else (Nothing            , avails &amp; mapped . mapped *~ newAvailPerc)
</span></pre></body></html>