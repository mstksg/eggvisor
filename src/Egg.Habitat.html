<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds             #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DeriveFunctor         #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric         #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances     #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase            #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE OverloadedStrings     #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes            #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE RecordWildCards       #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables   #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TemplateHaskell       #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TupleSections         #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications      #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies          #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators         #-}</span><span>
</span><a name="line-16"></a><span class="hs-pragma">{-# LANGUAGE TypeSynonymInstances  #-}</span><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Habitat</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-19"></a><span>    </span><a href="Egg.Habitat.html#Hab"><span class="hs-identifier hs-type">Hab</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habName"><span class="hs-identifier hs-var">habName</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habBaseCapacity"><span class="hs-identifier hs-var">habBaseCapacity</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCosts"><span class="hs-identifier hs-var">habCosts</span></a><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HabData"><span class="hs-identifier hs-type">HabData</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HabData"><span class="hs-identifier hs-var">_HabData</span></a><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#SomeHabData"><span class="hs-identifier hs-type">SomeHabData</span></a><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HabStatus"><span class="hs-identifier hs-type">HabStatus</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HabStatus"><span class="hs-identifier hs-var">_HabStatus</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#hsSlots"><span class="hs-identifier hs-var">hsSlots</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#hsPop"><span class="hs-identifier hs-var">hsPop</span></a><span>
</span><a name="line-23"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#IsCalm"><span class="hs-identifier hs-type">IsCalm</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NotCalm"><span class="hs-identifier hs-var">_NotCalm</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_Calm"><span class="hs-identifier hs-var">_Calm</span></a><span>
</span><a name="line-24"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#initHabStatus"><span class="hs-identifier hs-var">initHabStatus</span></a><span>
</span><a name="line-25"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habAt"><span class="hs-identifier hs-var">habAt</span></a><span>
</span><a name="line-26"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#totalChickens"><span class="hs-identifier hs-var">totalChickens</span></a><span>
</span><a name="line-27"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#baseHabCapacity"><span class="hs-identifier hs-var">baseHabCapacity</span></a><span>
</span><a name="line-28"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#baseHabCapacities"><span class="hs-identifier hs-var">baseHabCapacities</span></a><span>
</span><a name="line-29"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#totalHabCapacity"><span class="hs-identifier hs-var">totalHabCapacity</span></a><span>
</span><a name="line-30"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCapacity"><span class="hs-identifier hs-var">habCapacity</span></a><span>
</span><a name="line-31"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#fullHabs"><span class="hs-identifier hs-var">fullHabs</span></a><span>
</span><a name="line-32"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#availableSpace"><span class="hs-identifier hs-var">availableSpace</span></a><span>
</span><a name="line-33"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#maxOutHabs"><span class="hs-identifier hs-var">maxOutHabs</span></a><span>
</span><a name="line-34"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habCapacities"><span class="hs-identifier hs-var">habCapacities</span></a><span>
</span><a name="line-35"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habHistory"><span class="hs-identifier hs-var">habHistory</span></a><span>
</span><a name="line-36"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#habPrice"><span class="hs-identifier hs-var">habPrice</span></a><span>
</span><a name="line-37"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#upgradeHab"><span class="hs-identifier hs-var">upgradeHab</span></a><span>
</span><a name="line-38"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#internalHatcheryRate"><span class="hs-identifier hs-var">internalHatcheryRate</span></a><span>
</span><a name="line-39"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#HWaitError"><span class="hs-identifier hs-type">HWaitError</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HWENoInternalHatcheries"><span class="hs-identifier hs-var">_HWENoInternalHatcheries</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_HWEMaxHabCapacity"><span class="hs-identifier hs-var">_HWEMaxHabCapacity</span></a><span>
</span><a name="line-40"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#waitTilNextFilled"><span class="hs-identifier hs-var">waitTilNextFilled</span></a><span>
</span><a name="line-41"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#stepHabs"><span class="hs-identifier hs-var">stepHabs</span></a><span>
</span><a name="line-42"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#WaitTilRes"><span class="hs-identifier hs-type">WaitTilRes</span></a><span class="hs-special">(</span><a href="Egg.Habitat.html#WaitTilSuccess"><span class="hs-identifier hs-var">WaitTilSuccess</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#MaxPopIn"><span class="hs-identifier hs-var">MaxPopIn</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#NoWait"><span class="hs-identifier hs-var">NoWait</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#NoInternalHatcheries"><span class="hs-identifier hs-var">NoInternalHatcheries</span></a><span class="hs-special">)</span><span>
</span><a name="line-43"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_WaitTilSuccess"><span class="hs-identifier hs-var">_WaitTilSuccess</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_MaxPopIn"><span class="hs-identifier hs-var">_MaxPopIn</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NoWait"><span class="hs-identifier hs-var">_NoWait</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#_NoInternalHatcheries"><span class="hs-identifier hs-var">_NoInternalHatcheries</span></a><span>
</span><a name="line-44"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#wtrTime"><span class="hs-identifier hs-var">wtrTime</span></a><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#wtrRes"><span class="hs-identifier hs-var">wtrRes</span></a><span>
</span><a name="line-45"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#waitTilPop"><span class="hs-identifier hs-var">waitTilPop</span></a><span>
</span><a name="line-46"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Egg.Habitat.html#fillTimes"><span class="hs-identifier hs-var">fillTimes</span></a><span>
</span><a name="line-47"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-48"></a><span>
</span><a name="line-49"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span>
</span><a name="line-50"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span> </span><span class="hs-keyword">hiding</span><span>        </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">.=</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-51"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>
</span><a name="line-52"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Trans</span><span class="hs-operator">.</span><span class="hs-identifier">Writer</span><span>
</span><a name="line-53"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span><span>
</span><a name="line-54"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Dependent</span><span class="hs-operator">.</span><span class="hs-identifier">Sum</span><span>
</span><a name="line-55"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Finite</span><span>
</span><a name="line-56"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-57"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-58"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-59"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Tuple</span><span>
</span><a name="line-60"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Combinator.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TC</span><span>
</span><a name="line-61"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Fin</span><span>
</span><a name="line-62"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>           </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-63"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Vector.Sized.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-64"></a><span class="hs-keyword">import</span><span>           </span><a href="Egg.Commodity.html"><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Commodity</span></a><span>
</span><a name="line-65"></a><span class="hs-keyword">import</span><span>           </span><a href="Egg.Research.html"><span class="hs-identifier">Egg</span><span class="hs-operator">.</span><span class="hs-identifier">Research</span></a><span>
</span><a name="line-66"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-67"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TL</span><span>
</span><a name="line-68"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span>
</span><a name="line-69"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Natural</span><span>
</span><a name="line-70"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Printf</span><span>
</span><a name="line-71"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-72"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Map</span><span>                   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">M</span><span>
</span><a name="line-73"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span>
</span><a name="line-74"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SV</span><span>
</span><a name="line-75"></a><span>
</span><a name="line-76"></a><span class="hs-keyword">data</span><span> </span><a name="Hab"><a href="Egg.Habitat.html#Hab"><span class="hs-identifier">Hab</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="Hab"><a href="Egg.Habitat.html#Hab"><span class="hs-identifier">Hab</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="_habName"><a href="Egg.Habitat.html#_habName"><span class="hs-identifier">_habName</span></a></a><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">T</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">Text</span><span>
</span><a name="line-77"></a><span>               </span><span class="hs-special">,</span><span> </span><a name="_habBaseCapacity"><a href="Egg.Habitat.html#_habBaseCapacity"><span class="hs-identifier">_habBaseCapacity</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Natural</span><span>
</span><a name="line-78"></a><span>               </span><span class="hs-special">,</span><span> </span><a name="_habCosts"><a href="Egg.Habitat.html#_habCosts"><span class="hs-identifier">_habCosts</span></a></a><span>        </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Vec</span><span> </span><span class="hs-identifier hs-type">N4</span><span> </span><a href="Egg.Commodity.html#Bock"><span class="hs-identifier hs-type">Bock</span></a><span>
</span><a name="line-79"></a><span>               </span><span class="hs-special">}</span><span>
</span><a name="line-80"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-81"></a><span>
</span><a name="line-82"></a><span class="hs-identifier hs-var">makeLenses</span><span> </span><span class="hs-char">''Hab

newtype HabData habs = HabData { _hdHabs :: SV.Vector habs Hab }
  deriving (Show, Eq, Ord, Generic)

makePrisms ''HabData
makeWrapped ''HabData

type SomeHabData = DSum Sing HabData

data HabStatus habs
    = HabStatus { _hsSlots :: Vec N4 (Maybe (Finite habs))
                , _hsPop   :: Vec N4 Bock
                }
  deriving (Show, Eq, Ord, Generic)

makeLenses ''HabStatus

_HabStatus :: Iso' (HabStatus habs) (Vec N4 (Maybe (Finite habs), Double))
_HabStatus = iso (\hs -&gt; liftA2 (,) (_hsSlots hs) (_hsPop hs))
                 (uncurry HabStatus . unzipV)

habParseOptions :: Options
habParseOptions = defaultOptions
    { fieldLabelModifier = camelTo2 '-' . drop 4
    }

instance FromJSON Hab where
    parseJSON  = genericParseJSON  habParseOptions
instance ToJSON Hab where
    toJSON     = genericToJSON     habParseOptions
    toEncoding = genericToEncoding habParseOptions

instance FromJSON SomeHabData where
    parseJSON o = do
      habs &lt;- parseJSON o
      SV.withSized habs $ \habsV -&gt;
        return $ SNat :=&gt; HabData habsV
instance ToJSON SomeHabData where
    toJSON = \case
        _ :=&gt; r -&gt; toJSON r
    toEncoding = \case
        _ :=&gt; r -&gt; toEncoding r
instance KnownNat habs =&gt; FromJSON (HabData habs) where
    parseJSON o = do
      habs &lt;- parseJSON o
      case SV.toSized habs of
        Nothing    -&gt; fail $ printf &quot;Bad number of items in list. (Expected %d, got %d)&quot;
                         (fromSing (SNat @habs)) (length habs)
        Just habsV -&gt; return $ HabData habsV
instance ToJSON (HabData habs) where
    toJSON     = toJSON     . SV.fromSized . _hdHabs
    toEncoding = toEncoding . SV.fromSized . _hdHabs

data IsCalm = NotCalm | Calm
    deriving (Show, Eq, Ord, Enum)

makePrisms ''IsCalm

data WaitTilRes a
    = WaitTilSuccess { _wtrTime :: Double, _wtrRes :: a }
    | MaxPopIn       { _wtrTime :: Double }
    | NoWait
    | NoInternalHatcheries
  deriving (Show, Eq, Ord, Functor)

makePrisms ''WaitTilRes
makeLenses ''WaitTilRes

data HWaitError = HWENoInternalHatcheries
                | HWEMaxHabCapacity

makePrisms ''HWaitError

-- | Initial 'HabStatus' to start off the game.
initHabStatus :: (KnownNat habs, 1 TL.&lt;= habs) =&gt; HabStatus habs
initHabStatus = HabStatus (Just 0 :+ pure Nothing) (pure 0)

-- | Base capacity of each slot.
baseHabCapacities
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; HabStatus habs
    -&gt; Vec N4 Natural
baseHabCapacities hd = fmap go . _hsSlots
  where
    go = maybe 0 (\h -&gt; hd ^. _HabData . ixSV h . habBaseCapacity)

-- | Total base capacity of all slots.
baseHabCapacity
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; HabStatus habs
    -&gt; Natural
baseHabCapacity HabData{..} =
    sumOf $ hsSlots
          . traverse
          . traverse
          . to (SV.index _hdHabs)
          . habBaseCapacity

-- | Total capacity of all hatcheries, factoring in bonuses.
totalHabCapacity
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Natural
totalHabCapacity hd bs =
    sumOf $ to (baseHabCapacity hd)
          . to fromIntegral
          . bonusingFor bs BTHabCapacity
          . to round

-- | Capacities of all slots, factoring in bonuses.
habCapacities
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 Natural
habCapacities hd bs = fmap ( round
                        . bonusEffectFor bs BTHabCapacity
                        . fromIntegral
                        )
                    . baseHabCapacities hd

-- | Hab at the given slot
habAt :: KnownNat habs =&gt; HabData habs -&gt; HabStatus habs -&gt; Fin N4 -&gt; Maybe Hab
habAt HabData{..} hs i = hs ^? hsSlots . ixV i . traverse . to (SV.index _hdHabs)

-- | Total number of chickens
totalChickens
    :: HabData habs
    -&gt; HabStatus habs
    -&gt; Double
totalChickens HabData{..} = sumOf $ hsPop . traverse

-- | How many of each hab is currently owned.  If key is not found, zero
-- purchases is implied.
habHistory :: HabStatus habs -&gt; M.Map (Finite habs) (Fin N5)
habHistory = M.mapMaybe (natFin . someNat)
           . M.fromListWith (+)
           . toListOf (hsSlots . traverse . traverse . to (, 1))

-- | Get the BASE price of a given hab, if a purchase were to be made.
-- Does not check if purchase is legal (see 'upgradeHab').
habPrice :: KnownNat habs =&gt; HabData habs -&gt; HabStatus habs -&gt; Finite habs -&gt; Maybe Bock
habPrice hd hs hab = fmap priceOf
                   . TC.strengthen
                   . fromMaybe FZ
                   . M.lookup hab
                   . habHistory
                   $ hs
  where
    priceOf :: Fin N4 -&gt; Bock
    priceOf i = hd ^. _HabData . ixSV hab . habCosts . ixV i

-- | Get the actual capacity for a given hab, with given bonuses.
habCapacity
    :: Bonuses
    -&gt; Hab
    -&gt; Natural
habCapacity bs = view $ habBaseCapacity
                      . to fromIntegral
                      . bonusingFor bs BTHabCapacity
                      . to round

-- | Compute the base internal hatchery rate (chickens per second per
-- hatchery) from bonuses.
internalHatcheryRate :: Bonuses -&gt; IsCalm -&gt; Double
internalHatcheryRate bs cm =
    0 ^. bonusingFor bs BTInternalHatchery . dividing 60 . multiplying calmBonus
  where
    calmBonus = case cm of
        NotCalm -&gt; 1
        Calm    -&gt; 1 ^. bonusingFor bs BTInternalHatcheryCalm

-- | Purchase a hab upgrade.  Returns cost and new hab status, if
-- purchase is valid.
--
-- Purchase is invalid if purchasing a hab in a slot where a greater hab
-- is already purchased.
upgradeHab
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; Fin N4
    -&gt; Finite habs
    -&gt; HabStatus habs
    -&gt; Maybe (Bock, HabStatus habs)
upgradeHab hd bs slot hab hs0 =
    fmap swap . runWriterT . flip (hsSlots . ixV slot) hs0 $ \s0 -&gt; WriterT $ do
      guard $ case s0 of
                Nothing -&gt; True
                Just h  -&gt; h &lt; hab
      -- should always be valid of the previous condition is true
      price &lt;- habPrice hd hs0 hab
      return (Just hab, price ^. bonusingFor bs BTBuildCosts)

-- | Which habs are full?
fullHabs
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 Bool
fullHabs hd bs = fmap (uncurry isFull) . view _HabStatus
  where
    isFull :: Maybe (Finite habs) -&gt; Double -&gt; Bool
    isFull s c = case s of
      Nothing -&gt; True
      Just m  -&gt;
        let totCap = hd ^. _HabData . ixSV m . to (habCapacity bs)
        in  c &gt;= fromIntegral totCap

-- | Gives total avaiable space of each hab (Nothing if hab full), and also
-- the capacity of each hab.
availableSpace
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; Vec N4 (Maybe Double, Natural)
availableSpace hd bs hs = checkAvail &lt;$&gt; caps &lt;*&gt; (hs ^. hsPop)
  where
    caps :: Vec N4 Natural
    caps   = habCapacities hd bs hs
    checkAvail :: Natural -&gt; Double -&gt; (Maybe Double, Natural)
    checkAvail cap pop
        | pop &gt;= cap' = (Nothing, cap)
        | otherwise   = (Just (cap' - pop), cap)
      where
        cap' = fromIntegral cap

-- | Fill up with max chickens
maxOutHabs
    :: KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; HabStatus habs
    -&gt; HabStatus habs
maxOutHabs hd bs = over (_HabStatus . mapped) $ \(h, _) -&gt;
    case h of
      Nothing -&gt; (h, 0)
      Just m  -&gt;
        let totCap = hd ^. _HabData . ixSV m . to (habCapacity bs)
        in  (h, fromIntegral totCap)

-- | Calculate the time until the next hab is full, and return the updated
-- habs after that time.  Returns Nothing if all habs are full.
--
-- Also returns the current total fill rate per hatchery, taking into
-- account all bonuses.
--
-- Conclusions:
--
-- 1. No internal hatcheries
-- 2. All habs are already full.
-- 3. Hab n filled after a given amount of time.
waitTilNextFilled
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; HabStatus habs
    -&gt; Either HWaitError (((Fin N4, Double), Double), HabStatus habs)
waitTilNextFilled hd bs cm hs
    | internalRate &lt;= 0 = Left HWENoInternalHatcheries
    | otherwise         = case nextFill of
        Nothing      -&gt; Left HWEMaxHabCapacity
        Just r@(_,t) -&gt; Right ((r, totalRate), fillIt t)
  where
    avails :: Vec N4 (Maybe Double, Natural)
    avails = availableSpace hd bs hs
    internalRate :: Double
    internalRate = internalHatcheryRate bs cm
    numFull      :: Natural
    numFull      = sumOf (traverse . to (maybe 1 (const 0) . fst)) avails
    sharingRate  :: Double
    sharingRate  = 0 ^. bonusingFor bs BTInternalHatcherySharing
    totalRate    :: Double
    totalRate    = internalRate * (1 + sharingRate * fromIntegral numFull)
    fillAtRate   :: Vec N4 (Maybe Double)
    fillAtRate = (fst &lt;$&gt; avails) &amp; mapped . mapped %~ (/ totalRate)
    nextFill :: Maybe (Fin N4, Double)
    nextFill = ifoldr (go . fst) Nothing fillAtRate
      where
        go  :: Fin N4
            -&gt; Maybe Double
            -&gt; Maybe (Fin N4, Double)
            -&gt; Maybe (Fin N4, Double)
        go i (Just t) m@(Just (_, mt)) | t &lt; mt    = Just (i, t)
                                       | otherwise = m
        go i mt      Nothing                       = (i,) &lt;$&gt; mt
        go _ Nothing m@(Just _)                    = m
    fillIt :: Double -&gt; HabStatus habs
    fillIt t = hs &amp; hsPop %~
      liftA2 (\(a, _) -&gt; maybe id (const (+ totalRate * t)) a) avails

-- | Times for each hab to be filled.
fillTimes
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; HabStatus habs
    -&gt; Either HWaitError (Vec N4 Double)
fillTimes hd bs cm hs0 = go space0 hs0
  where
    space0 = maybe (Just 0) (const Nothing ) . fst &lt;$&gt;
               availableSpace hd bs hs0
    go  :: Vec N4 (Maybe Double)
        -&gt; HabStatus habs
        -&gt; Either HWaitError (Vec N4 Double)
    go ts0 hs1 = do
      (((n, t), _), hs2) &lt;- waitTilNextFilled hd bs cm hs1
      let ts1 = ts0 &amp; ixV n .~ Just t
      case sequence ts1 of
        Just ts -&gt; return ts
        Nothing -&gt; liftA2 (maybe id (+)) ts1 &lt;$&gt; go ts1 hs2

-- | Steps the 'HabStatus' over the given time interval.
stepHabs
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; Double           -- ^ time interval to step
    -&gt; HabStatus habs   -- ^ initial status
    -&gt; HabStatus habs
stepHabs hd bs cm = go
  where
    go :: Double -&gt; HabStatus habs -&gt; HabStatus habs
    go dt hs0 = case waitTilNextFilled hd bs cm hs0 of
        Left  _                       -&gt; hs0
        Right (((_, tFill), rt), hs1)
          | dt &lt; tFill -&gt; hs0 &amp; hsPop %~
                liftA2 (\(a, _) -&gt; maybe id (const (+ rt * dt)) a) avails
          | otherwise  -&gt;
                go (dt - tFill) hs1
      where
        avails = availableSpace hd bs hs0

-- | Time until a given population is reached.
waitTilPop
    :: forall habs. KnownNat habs
    =&gt; HabData habs
    -&gt; Bonuses
    -&gt; IsCalm
    -&gt; Natural
    -&gt; HabStatus habs
    -&gt; WaitTilRes (HabStatus habs)
waitTilPop hd bs cm goal hs0
    | pop0 &gt; goal' = NoWait
    | otherwise    = go pop0 hs0
  where
    goal' = fromIntegral goal
    pop0 :: Double
    pop0 = sumOf (hsPop . traverse) hs0
    go :: Double -&gt; HabStatus habs -&gt; WaitTilRes (HabStatus habs)
    go currPop hs1 = case waitTilNextFilled hd bs cm hs1 of
      Left HWENoInternalHatcheries -&gt; NoInternalHatcheries
      Left HWEMaxHabCapacity       -&gt; MaxPopIn 0
      Right (((_, dt), rt), hs2)  -&gt;
        let newPop = sumOf (hsPop . traversed) hs2
            avails = availableSpace hd bs hs1
        in  if newPop &gt;= goal'
              then let dt'    = (goal' - currPop) / rt
                       filled = hs2 &amp; hsPop %~
                         liftA2 (\(a, _) -&gt; maybe id (const (+ rt * dt')) a) avails
                   in  WaitTilSuccess dt' filled
              else go newPop hs2 &amp; wtrTime +~ dt
</span></pre></body></html>