<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes                  #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE ConstraintKinds                      #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE DataKinds                            #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric                        #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE EmptyCase                            #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts                     #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances                    #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE GADTs                                #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase                           #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses                #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE PartialTypeSignatures                #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE PolyKinds                            #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes                           #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables                  #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving                   #-}</span><span>
</span><a name="line-16"></a><span class="hs-pragma">{-# LANGUAGE TemplateHaskell                      #-}</span><span>
</span><a name="line-17"></a><span class="hs-pragma">{-# LANGUAGE TupleSections                        #-}</span><span>
</span><a name="line-18"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications                     #-}</span><span>
</span><a name="line-19"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies                         #-}</span><span>
</span><a name="line-20"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilyDependencies               #-}</span><span>
</span><a name="line-21"></a><span class="hs-pragma">{-# LANGUAGE TypeInType                           #-}</span><span>
</span><a name="line-22"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators                        #-}</span><span>
</span><a name="line-23"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances                 #-}</span><span>
</span><a name="line-24"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans                 #-}</span><span>
</span><a name="line-25"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-partial-type-signatures #-}</span><span>
</span><a name="line-26"></a><span>
</span><a name="line-27"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-28"></a><span>    </span><a href="Data.Type.Combinator.Util.html#HasLen"><span class="hs-identifier hs-type">HasLen</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-29"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#withProd"><span class="hs-identifier hs-var">withProd</span></a><span>
</span><a name="line-30"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#unzipP"><span class="hs-identifier hs-var">unzipP</span></a><span>
</span><a name="line-31"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#zipP"><span class="hs-identifier hs-var">zipP</span></a><span>
</span><a name="line-32"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#allWit"><span class="hs-identifier hs-var">allWit</span></a><span>
</span><a name="line-33"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#allWit%27"><span class="hs-identifier hs-var">allWit'</span></a><span>
</span><a name="line-34"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#tagSum"><span class="hs-identifier hs-var">tagSum</span></a><span>
</span><a name="line-35"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#sumIso"><span class="hs-identifier hs-var">sumIso</span></a><span>
</span><a name="line-36"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#sumSome"><span class="hs-identifier hs-var">sumSome</span></a><span>
</span><a name="line-37"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#someSum"><span class="hs-identifier hs-var">someSum</span></a><span>
</span><a name="line-38"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#ixProd"><span class="hs-identifier hs-var">ixProd</span></a><span>
</span><a name="line-39"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#ixVecT"><span class="hs-identifier hs-var">ixVecT</span></a><span>
</span><a name="line-40"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#ixV"><span class="hs-identifier hs-var">ixV</span></a><span>
</span><a name="line-41"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#_Flip"><span class="hs-identifier hs-var">_Flip</span></a><span>
</span><a name="line-42"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#_C"><span class="hs-identifier hs-var">_C</span></a><span>
</span><a name="line-43"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#sumProd"><span class="hs-identifier hs-var">sumProd</span></a><span>
</span><a name="line-44"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#for1"><span class="hs-identifier hs-var">for1</span></a><span>
</span><a name="line-45"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#Replicate"><span class="hs-identifier hs-type">Replicate</span></a><span>
</span><a name="line-46"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#vecToProd"><span class="hs-identifier hs-var">vecToProd</span></a><span>
</span><a name="line-47"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#vecToAnyProd"><span class="hs-identifier hs-var">vecToAnyProd</span></a><span>
</span><a name="line-48"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#addFinCap"><span class="hs-identifier hs-var">addFinCap</span></a><span>
</span><a name="line-49"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#strengthen"><span class="hs-identifier hs-var">strengthen</span></a><span>
</span><a name="line-50"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#strengthenN"><span class="hs-identifier hs-var">strengthenN</span></a><span>
</span><a name="line-51"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#natFin"><span class="hs-identifier hs-var">natFin</span></a><span>
</span><a name="line-52"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#natFinCap"><span class="hs-identifier hs-var">natFinCap</span></a><span>
</span><a name="line-53"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#ixListFin"><span class="hs-identifier hs-var">ixListFin</span></a><span>
</span><a name="line-54"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#ixListNat"><span class="hs-identifier hs-var">ixListNat</span></a><span>
</span><a name="line-55"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#zipFins"><span class="hs-identifier hs-var">zipFins</span></a><span>
</span><a name="line-56"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#someNat"><span class="hs-identifier hs-var">someNat</span></a><span>
</span><a name="line-57"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#unzipV"><span class="hs-identifier hs-var">unzipV</span></a><span>
</span><a name="line-58"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#fins%27"><span class="hs-identifier hs-var">fins'</span></a><span>
</span><a name="line-59"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#dsumSome"><span class="hs-identifier hs-var">dsumSome</span></a><span>
</span><a name="line-60"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#someDSum"><span class="hs-identifier hs-var">someDSum</span></a><span>
</span><a name="line-61"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#liftTraversal"><span class="hs-identifier hs-var">liftTraversal</span></a><span>
</span><a name="line-62"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Data.Type.Combinator.Util.html#addCommute"><span class="hs-identifier hs-var">addCommute</span></a><span>
</span><a name="line-63"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-64"></a><span>
</span><a name="line-65"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">L</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-type">:&lt;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Index</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Traversable1</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-66"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span>
</span><a name="line-67"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span><span>
</span><a name="line-68"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Bifunctor</span><span>
</span><a name="line-69"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Constraint</span><span class="hs-operator">.</span><span class="hs-identifier">Forall</span><span>
</span><a name="line-70"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Dependent</span><span class="hs-operator">.</span><span class="hs-identifier">Sum</span><span>
</span><a name="line-71"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>            </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">F</span><span>
</span><a name="line-72"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">GADT</span><span class="hs-operator">.</span><span class="hs-identifier">Compare</span><span>
</span><a name="line-73"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">GADT</span><span class="hs-operator">.</span><span class="hs-identifier">Show</span><span>
</span><a name="line-74"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-75"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span>
</span><a name="line-76"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Conjunction</span><span>
</span><a name="line-77"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Fin</span><span>
</span><a name="line-78"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Index</span><span>
</span><a name="line-79"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span>
</span><a name="line-80"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-81"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span class="hs-operator">.</span><span class="hs-identifier">Inequality</span><span>
</span><a name="line-82"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-83"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Sum</span><span>
</span><a name="line-84"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-85"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>             </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-86"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Natural</span><span>
</span><a name="line-87"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Printf</span><span>
</span><a name="line-88"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span>
</span><a name="line-89"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Known</span><span>
</span><a name="line-90"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Witness</span><span>
</span><a name="line-91"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Constraint</span><span>
</span><a name="line-92"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-93"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-94"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Constraint</span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">C</span><span>
</span><a name="line-95"></a><span>
</span><a name="line-96"></a><span class="hs-keyword">data</span><span> </span><a name="HasLen"><a href="Data.Type.Combinator.Util.html#HasLen"><span class="hs-identifier">HasLen</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">N</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679251995"><span class="hs-identifier hs-type">k</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-97"></a><span>    </span><a name="HLZ"><a href="Data.Type.Combinator.Util.html#HLZ"><span class="hs-identifier">HLZ</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.Type.Combinator.Util.html#HasLen"><span class="hs-identifier hs-type">HasLen</span></a><span> </span><span class="hs-char">'Z '[]
    HLS :: HasLen n as -&gt; HasLen ('S n) (a ': as)

withProd
    :: forall n f g a. ()
    =&gt; (f a -&gt; Some g)
    -&gt; VecT n f a
    -&gt; Some (HasLen n :&amp;: Prod g)
withProd f = go
  where
    go :: VecT m f a -&gt; Some (HasLen m :&amp;: Prod g)
    go = \case
      &#216;V      -&gt; Some (HLZ :&amp;: &#216;)
      x :* xs -&gt; some (f x)   $ \y -&gt;
                 some (go xs) $ \(hl :&amp;: ys) -&gt;
        Some (HLS hl :&amp;: (y :&lt; ys))

unzipP
    :: Prod (f :&amp;: g) as
    -&gt; (Prod f :&amp;: Prod g) as
unzipP = \case
    &#216;               -&gt; &#216; :&amp;: &#216;
    (x :&amp;: y) :&lt; zs -&gt; case unzipP zs of
      xs :&amp;: ys -&gt; (x :&lt; xs) :&amp;: (y :&lt; ys)

zipP
    :: (Prod f :&amp;: Prod g) as
    -&gt; Prod (f :&amp;: g) as
zipP = \case
    &#216;         :&amp;: &#216;         -&gt; &#216;
    (x :&lt; xs) :&amp;: (y :&lt; ys) -&gt; (x :&amp;: y) :&lt; zipP (xs :&amp;: ys)

allWit'
    :: Prod (Wit :.: c) as
    -&gt; Wit (ListC (c &lt;$&gt; as))
allWit' = \case
    &#216;           -&gt; Wit
    Comp Wit :&lt; wits -&gt; case allWit' wits of
      Wit -&gt; Wit

allWit
    :: forall f c as. ()
    =&gt; (forall a. f a -&gt; Wit (c a))
    -&gt; Prod f as
    -&gt; Wit (ListC (c &lt;$&gt; as))
allWit f = allWit' . map1 (Comp . f)

tagSum
    :: Prod f as
    -&gt; Sum g as
    -&gt; Sum (f :&amp;: g) as
tagSum = \case
    &#216;       -&gt; \case
    x :&lt; xs -&gt; \case
      InL y  -&gt; InL (x :&amp;: y)
      InR ys -&gt; InR (tagSum xs ys)

sumIso :: Iso' (Sum f as) (Some (Index as :&amp;: f))
sumIso = iso sumSome someSum

sumSome :: Sum f as -&gt; Some (Index as :&amp;: f)
sumSome = \case
    InL x  -&gt; Some (IZ :&amp;: x)
    InR xs -&gt; some (sumSome xs) $ \(i :&amp;: y) -&gt;
                Some (IS i :&amp;: y)

someSum :: forall f as. Some (Index as :&amp;: f) -&gt; Sum f as
someSum = withSome (uncurryFan go)
  where
    go :: forall bs a. Index bs a -&gt; f a -&gt; Sum f bs
    go = \case
      IZ   -&gt; InL
      IS i -&gt; InR . go i

ixProd :: Index as a -&gt; Lens' (Prod f as) (f a)
ixProd = \case
    IZ -&gt; \f -&gt; \case
      x :&lt; xs -&gt; (:&lt; xs) &lt;$&gt; f x
    IS i -&gt; \f -&gt; \case
      x :&lt; xs -&gt; (x :&lt;) &lt;$&gt; ixProd i f xs

ixVecT :: Fin n -&gt; Lens' (VecT n f a) (f a)
ixVecT = \case
    FZ   -&gt; \f -&gt; \case
      x :* xs -&gt; (:* xs) &lt;$&gt; f x
    FS n -&gt; \f -&gt; \case
      x :* xs -&gt; (x :*) &lt;$&gt; ixVecT n f xs

ixV :: Fin n -&gt; Lens' (Vec n a) a
ixV = \case
    FZ   -&gt; \f -&gt; \case
      I x :* xs -&gt; (:+ xs) &lt;$&gt; f x
    FS n -&gt; \f -&gt; \case
      x   :* xs -&gt; (x :*) &lt;$&gt; ixV n f xs

makePrisms ''Flip
makeWrapped ''Flip

makePrisms ''C
makeWrapped ''C

makePrisms ''(:.:)
makeWrapped ''(:.:)

sumProd
    :: Functor h
    =&gt; (forall a. (f :&amp;: g) a -&gt; h ((f :&amp;: g) a))
    -&gt; (Sum f :&amp;: Prod g) as
    -&gt; h ((Sum f :&amp;: Prod g) as)
sumProd f = uncurryFan $ \case
    InL x  -&gt; \case
      y :&lt; ys -&gt; (InL .&amp;. (:&lt; ys)) &lt;$&gt; f (x :&amp;: y)
    InR xs -&gt; \case
      y :&lt; ys -&gt; (InR .&amp;. (y  :&lt;)) &lt;$&gt; sumProd f (xs :&amp;: ys)

instance Field1 ((f :&amp;: g) a) ((h :&amp;: g) a) (f a) (h a) where
    _1 f (x :&amp;: y) = (:&amp;: y) &lt;$&gt; f x

instance Field2 ((f :&amp;: g) a) ((f :&amp;: h) a) (g a) (h a) where
    _2 f (x :&amp;: y) = (x :&amp;:) &lt;$&gt; f y

-- sumProd = \case
--     InL x -&gt; \f -&gt; \case
--       y :&lt; ys -&gt; (:&lt; ys) . fanSnd &lt;$&gt; f (x :&amp;: y)
--     InR xs -&gt; \f -&gt; \case
--       y :&lt; ys -&gt; (y :&lt;) &lt;$&gt; sumProd xs f ys

-- sumProd :: (Sum f :&amp;: Prod g) as -&gt; Sum (f :&amp;: g) as

-- sumProd :: Sum f as -&gt; Lens' (Prod g as) (Sum (f :&amp;: g) as)
-- sumProd = \case
--     InL x -&gt; \f -&gt; \case
--       y :&lt; ys -&gt; f (InL (x :&amp;: y)) &lt;&amp;&gt; _

-- sumProd :: Sum f as -&gt; Lens' (Prod g as) (Some (f :&amp;: g))
-- sumProd = \case
--     InL x -&gt; \f -&gt; \case
--       y :&lt; ys -&gt; f (Some (x :&amp;: y)) &lt;&amp;&gt; \case Some (x' :&amp;: y') -&gt; y' :&lt; ys

instance (Known Nat n, FromJSON a) =&gt; FromJSON (Vec n a) where
    parseJSON o = do
      xs &lt;- parseJSON o
      case listVec known xs of
        Nothing -&gt; fail $ printf &quot;Bad number of items in list. (Expected %d, got %d)&quot;
                            (natVal (known @_ @Nat @n)) (length xs)
        Just ys -&gt; return ys
instance ToJSON a =&gt; ToJSON (Vec n a) where
    toJSON     = toJSON . F.toList
    toEncoding = toEncoding . F.toList

instance (Every (Comp FromJSON f) as, Known Length as) =&gt; FromJSON (Prod f as) where
    parseJSON = withArray &quot;Prod f as&quot; (go TCP.indices . F.toList)
      where
        go  :: forall bs. ()
            =&gt; Prod (Index as) bs
            -&gt; [Value]
            -&gt; Parser (Prod f bs)
        go = \case
          &#216; -&gt; \case
            []  -&gt; return &#216;
            _:_ -&gt; fail &quot;Too many items in array&quot;
          i :&lt; is -&gt; \case
            []   -&gt; fail &quot;Too few items in array&quot;
            x:xs -&gt; (:&lt;) &lt;$&gt; (parseJSON x \\ every @_ @(Comp FromJSON f) i)
                         &lt;*&gt; go is xs
instance Every (Comp ToJSON f) as =&gt; ToJSON (Prod f as) where
    toJSON = toJSON . ifoldMap1 (\i x -&gt; [toJSON x] \\ every @_ @(Comp ToJSON f) i)
    toEncoding = toEncoding . toJSON @(Prod f as)

deriving instance Generic (Flip a b c)

instance ToJSON (f b a) =&gt; ToJSON (Flip f a b)
instance FromJSON (f b a) =&gt; FromJSON (Flip f a b)

listVec :: Nat n -&gt; [a] -&gt; Maybe (Vec n a)
listVec = \case
    Z_ -&gt; \case
      [] -&gt; Just &#216;V
      _  -&gt; Nothing
    S_ n -&gt; \case
      [] -&gt; Nothing
      x:xs -&gt; do
        ys &lt;- listVec n xs
        return (x :+ ys)

for1
    :: (Applicative h, Traversable1 t)
    =&gt; t f b
    -&gt; (forall a. f a -&gt; h (g a))
    -&gt; h (t g b)
for1 x f = traverse1 f x

type family Replicate (n :: N) (a :: k) = (as :: [k]) | as -&gt; n where
    Replicate 'Z     a = '[]
    Replicate ('S n) a = a ': Replicate n a

vecToProd
    :: VecT n f a
    -&gt; Prod f (Replicate n a)
vecToProd = \case
    &#216;V      -&gt; &#216;
    x :* xs -&gt; x :&lt; vecToProd xs

vecToAnyProd
    :: Vec n a
    -&gt; HasLen n as
    -&gt; Prod (C a) as
vecToAnyProd = \case
    &#216;V        -&gt; \case
      HLZ -&gt; &#216;
    I x :* xs -&gt; \case
      HLS hl -&gt; C x :&lt; vecToAnyProd xs hl

instance Known (HasLen 'Z) '[] where
    known = HLZ
instance Known (HasLen n) as =&gt; Known (HasLen ('S n)) (a ': as) where
    known = HLS known

addFinCap :: forall n. Known Nat n =&gt; Fin n -&gt; Fin n -&gt; Fin n
addFinCap FZ     m = m
addFinCap (FS n) m = natFinCap . finNat . FS $ addFinCap (weaken n :: Fin n) m

strengthenN :: Nat n -&gt; Fin m -&gt; Fin (n + m)
strengthenN = \case
    Z_   -&gt; id
    S_ n -&gt; FS . strengthenN n

strengthen :: Known Nat n =&gt; Fin ('S n) -&gt; Maybe (Fin n)
strengthen = natFin . finNat

natFin :: forall n. Known Nat n =&gt; Some Nat -&gt; Maybe (Fin n)
natFin = withSome (go known)
  where
    go :: forall m o. Nat m -&gt; Nat o -&gt; Maybe (Fin m)
    go = \case
      Z_   -&gt; \_ -&gt; Nothing
      S_ m -&gt; \case
        Z_   -&gt; Just FZ
        S_ o -&gt; FS &lt;$&gt; go m o

natFinCap :: forall n. Known Nat n =&gt; Some Nat -&gt; Fin ('S n)
natFinCap = withSome (go known)
  where
    go :: forall m o. Nat ('S m) -&gt; Nat o -&gt; Fin ('S m)
    go = \case
      S_ Z_ -&gt; \_ -&gt; FZ
      S_ (S_ m) -&gt; \case
        Z_   -&gt; FZ
        S_ o -&gt; FS $ go (S_ m) o

someNat :: Natural -&gt; Some Nat
someNat x | x &lt;= 0    = Some Z_
          | otherwise = some (someNat (x - 1)) (Some . S_)

unzipV :: Functor f =&gt; VecT n f (a, b) -&gt; (VecT n f a, VecT n f b)
unzipV = \case
    &#216;V       -&gt; (&#216;V, &#216;V)
    xy :* zs -&gt; case unzipV zs of
      (xs, ys) -&gt; (fmap fst xy :* xs, fmap snd xy :* ys)

fins' :: Nat n -&gt; Vec n (Fin n)
fins' = \case
    Z_   -&gt; &#216;V
    S_ n -&gt; FZ :+ (FS &lt;$&gt; fins' n)

zipFins :: forall n f a. Functor f =&gt; VecT n f a -&gt; VecT n f (Fin n, a)
zipFins = \case
    &#216;V      -&gt; &#216;V
    x :* xs -&gt; ((FZ,) &lt;$&gt; x) :* (first FS &lt;$&gt; zipFins xs)

instance (FunctorWithIndex i f, Functor f) =&gt; FunctorWithIndex (Fin n, i) (VecT n f) where
    imap f = TCV.imap $ \i -&gt; L.imap (\j x -&gt; f (i, j) x)
instance FoldableWithIndex i f =&gt; FoldableWithIndex (Fin n, i) (VecT n f) where
    ifoldMap f = TCV.ifoldMap $ \i -&gt; L.ifoldMap (\j x -&gt; f (i, j) x)
instance TraversableWithIndex i f =&gt; TraversableWithIndex (Fin n, i) (VecT n f) where
    itraverse f = TCV.itraverse $ \i -&gt; L.itraverse (\j x -&gt; f (i, j) x)

instance FunctorWithIndex () I where
    imap f = fmap (f ())
instance FoldableWithIndex () I where
    ifoldMap f = foldMap (f ())
instance TraversableWithIndex () I where
    itraverse f = traverse (f ())

dsumSome :: DSum f g -&gt; Some (f :&amp;: g)
dsumSome (t :=&gt; x) = Some (t :&amp;: x)

someDSum :: Some (f :&amp;: g) -&gt; DSum f g
someDSum = withSome $ \(t :&amp;: x) -&gt; t :=&gt; x

liftTraversal
    :: (Traversable1 t, Applicative f)
    =&gt; (forall a. LensLike' f (g a) b)
    -&gt; LensLike' f (t g as) b
liftTraversal t f = traverse1 (t f)

addCommute
    :: Nat n
    -&gt; Nat m
    -&gt; ((n + m) :~: (m + n))
addCommute = \case
    Z_ -&gt; \case
      Z_   -&gt; Refl
      S_ m -&gt; Refl \\ addZ m
    S_ n -&gt; \case
      Z_ -&gt; Refl \\ addZ n
      S_ m -&gt; Refl \\ addCommute n m \\ addS n m \\ addS m n

instance GShow Nat where
    gshowsPrec = showsPrec
instance GEq Nat where
    geq x y = case natCompare x y of
      Left _         -&gt; Nothing
      Right (Left e) -&gt; Just Refl \\ e
      Right _        -&gt; Nothing
instance GCompare Nat where
    gcompare x y = case natCompare x y of
      Left _         -&gt; GLT
      Right (Left e) -&gt; GEQ \\ e
      Right _        -&gt; GGT

instance ForallF Show f =&gt; ShowTag Nat f where
    showTaggedPrec (_ :: _ a) = showsPrec C.\\ instF @Show @f @a
instance ForallF Eq f =&gt; EqTag Nat f where
    eqTagged      (_ :: _ a) _ x y = x == y C.\\ instF @Eq @f @a
instance (ForallF Ord f, ForallF Eq f) =&gt; OrdTag Nat f where
    compareTagged (_ :: _ a) _ x y = compare x y C.\\ instF @Ord @f @a

ixListFin :: Fin n -&gt; Traversal' [a] a
ixListFin = \case
    FZ -&gt; \f -&gt; \case
      []   -&gt; pure []
      x:xs -&gt; (: xs) &lt;$&gt; f x
    FS i -&gt; \f -&gt; \case
      []   -&gt; pure []
      x:xs -&gt; (x :) &lt;$&gt; ixListFin i f xs

ixListNat :: Nat n -&gt; Traversal' [a] a
ixListNat= \case
    Z_ -&gt; \f -&gt; \case
      []   -&gt; pure []
      x:xs -&gt; (: xs) &lt;$&gt; f x
    S_ n -&gt; \f -&gt; \case
      []   -&gt; pure []
      x:xs -&gt; (x :) &lt;$&gt; ixListNat n f xs
</span></pre></body></html>